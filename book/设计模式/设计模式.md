# 第一章
    设计模式四要素：
    1模式名称:
    2问题：描述何时使用模式。他解释了设计问题和问题存在的前因后果，他可能面熟了特定设计
    的问题，怎样使用算法等。
    
    3解决方案：描述了设计的组成成分，它们之间的相互关系以及各自的职责和协作方式。
    4效果：描述模式应用的效果以及使用模式应权衡的东西
    
    
   设计模式分类：
   目的准则，
       行为型：
       结构型：
       创建型：
   范围准则：
        作用类
        作用对象
        
   设计模式如何解决设计问题
   1寻找合适的对象
       面向对象程序有对象组成，对象包括数据和对数据的进行操作的过程，过程通常称为方法和操作。 
       客户请求是是对象执行操作的唯一方法,操作又是对象改变内部数据的唯一方法。由于这些限制对象
       的内部是被封装的，他不能被直接访问，他的表示对于对象外部是不可见的。
       面向对象设计的最困难的部分是将对象分解为对象的集合。要考虑到很多因素：封装、粒度、依赖关系、
       灵活性、性能、演化、复用等等。
       
   2决定对象的粒度
   
   
   3指定对象的接口
        对象声明的每一个操作指定操作名、作为参数的对象和返回值，这就是所谓的操作的型构。对象操作定义的所有
        操作所有的操作的型构的集合被称为对象的接口。对象接口描述了该对象所能接受的全部请求的集合。
        
        类型：用来标识特定接口i的一个名字，如果一个对象接受接口所定义的所有操作请求
        
        动态绑定：当给对象发送请求时，所引起的具体操基于请求本身又与接收对象有关。支持不同请求的不同对象可能对请求的激发
        操作有不同的实现。发送给对象的请求和它相应操作在运行时刻的链接就被称为动态绑定。
        
        对象只有通过他们的接口才能与外部交流，对象接口与功能是分离的。不同对象可以对请求做不同实现
        也就是说两个相同接口的对象都能接受此请求。
        
        多态：
    
  4描述对象的实现
    对象的实现是由他的类决定的，他的类即制定了对象的内部数据表示，也定义了对象能完成的操作。
    
    对象是通过实例化类来创建，此对象被称为该类的实例。当实例化类时要给内部数据（有实例变量组成）
    分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例时由实例化同一个类来创建的。
    
    新的类可以由已经存在的类通过类继承来定义，当子类继承父类的是，子类包括了父类定义的所有操作和数据。
    子类的实例对象包含所有子类和父类定义的数据，且他们完成子类定义和父类定义的所有操作。
    
    抽象类的主要目的是为他的子类定义公共接口，一个抽象类要把它的部分或者全部擦欧总的实现延迟到子类中，因此一个
    抽象类不能被实例化。在抽象类中定义却没有实现的操作被称为抽象操作。非抽象类被称为具体类。
    
    子类能够改进和从新定义他们父类的操作。更具体的说类能够重定义弗雷定义的操作，重定义是的子类能阶官弗雷对请求
    的处理操作。类继承允许你只需要简单的扩展其他类就可以定义新类，从而定义具有相似功能的对象族。
    
    混入类：是给其他的类提供可选择的接口或功能的类，他与抽象类一样不能被实例化，混入类要求多继承。
    
  #### 接口继承与类继承的比较
        一个对象的类定义定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。
        但是对象的类型至于他的接口有关，接口即对象能响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。
        
        类继承根据一个对象的实现定义了另一个对象的实现，接口继承就是代码和方法的共享。然而接口继承描述了一个对象什么时候能
        被用来替代另一个对象。
    
   5运用复用机制
    继承和组合的比较
    复用：类继承（白箱复用）和对象组合（黑箱复用）
    类继承：
    对象结合：新的复杂功能通过租住或者组合来获得这种复用成为黑箱复用。对象组合要求被组合的对象具有良好定义的接口。
        
        优缺点：
        了集成实在编译时可静态定义的，且可以直接使用。类继承可以较方便的改变背负用的的实现。不足之处在于类继承是在编译时刻
        静态定义的，所以无法在运行时刻改变从父类结成的实现。弗雷通常定义了部分子类的具体实现，通常类继承被认为破坏了封装性
        子类中国的实现和弗莱有密切的依赖关系，以至于父类实现中的任何变化都必然导致子类的发生变化。解决方法就是汁即成抽象类。
        
        对象组合是通过获得对其他对象的对象的引用而在运行时刻动态定义的。组合要求对象彼此遵守彼此的接口约定，今儿更仔细的定义
        接口，而这些接口并不妨碍你讲一个对象那个和其他对象一起使用。对象之恩那个通过接口访问，不破坏封装性，只要类型一直
        还可以在运行时刻用一个对象来代替另一个对象，因为对象的实现基于接口所以是线上存在较少的依赖关系。
        
   #####设计的第二个原则：优先使用对象组合而不是类继承
   ##### 设计的第一原则对接口编程而不是对实现编程
   
   2委托是一种组合方法，它使组合具有集成同样的服用能力。两个对象请求一个请求，接受请求的对象将操作委托给他的代理者。
   接受请求的对象将自己传给委托者，是委托的操作可以引用接受请求的对象。
   
   委托的不足：
        动态的高度参数化的软件比静态软件更难理解，运行效率低。
        优点是他便与运行时刻组合对象操作的以及改变这些操作的组合方式。
        
        
   3参数化类型和继承的比较。（类属或者模板）
   参数化类型允许定义一个类型并不指定该类型所用到的其他所有类型。为指定的类型在使用在使用时以参数化形式提供。
   
   #### 1.6.6关联运行时刻和编译社科的结构
   
   
   
# 第二章 设计一个文档编辑器
## 递归结合
递归组合可以又比较简单的元素建立复杂的元素。

### 迭代器模式

    
#第三章创建型模式
创建型模式抽象了实例化过程，他们帮助一个系统独立于如何创建、组合和表示他的那些对象。一个类创建模式模式使用继承改变被实例化的类
。一个对象创建模式激昂实例化委托给另一个对象

## 3.1 抽象工厂
提供一个创建一些列相关或者相互以来的的对象的接口，而他无需制定他们的具体的类

场景：
    1一个系统独立于他的产品的创建、组合和表示时
    2一个系统要独立与他的产品的配置对
    

#第四章

# 第五章

# 第六章

# 第七章

# 第八章

# 第九章

# 第十章

# 数据库部分
## 一事物
事务指的是满足acid特性可以通过Cmmit提交一个一个事务，也可以Rollback进行回滚。
原子性;Atomicity
事务被视为不可分割的最小单元，事务的所有操作要么全部被提交成功，要么全部失败回滚。

一致性：Consistency

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有食物对一个数据的读取结果都是相同的。

隔离性ISOLATION

一个事务所做的修改在最终提交以前，对其他事务是不可见的。

持久性 Durability

一旦事务提交，则其做的的修改将会永久的保存在数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

## 二并发一致性问题
丢失修改

T1和T2两个事务都对一个数据进行修改，T1先修改T2后修改，T2的修改覆盖了T1的修改。

读脏数据

T1修改的数据，T2随后读取，如果T1撤销了这次修改，T2读的数据是脏数据。

不可重复读

T2读取一个数据T1对其进行了修改，T2再次读取这个数据，则读取的结果和第一次不同。

幻影读

T1读取的某个范围的数据，T2在这个范围插入新的数据，T1再次读取这个范围的数据，此时的读取的结果和第一次不同。


## 三 封锁
封锁的力度

mysql提供两种封锁的粒度：行级锁和表级锁。

原则：尽量之锁定所需要修改的那部分的数据，而不是所有数据。锁定的数据量越小，发生锁争用的可能越小，系统的并发程度越高。
但是枷锁需要消耗系统的资源，锁的各种操作都会增加系统的各种开销。因此封锁的粒度越小，系统的开销越大。

封锁的类型

1读写锁
    
    排它锁 简称为x锁 又称为写锁
    共享锁 简称s锁
    规定：
        一个事务对数据对象A加了写锁，就可以对A进行读取和更新。枷锁区间其他食物布恩那个对A加任何锁。
        一个事务对数据对象A加了读锁，可以对A进行读取操作，但是不能进行更新操作，其他事务可以对A家读锁但是不能加写锁
        
2意向锁
使用意向锁可以容易的支持多粒度封锁

在存在行级锁和表级锁的情况下，事务T要对表A家写锁，就需要检测是否有其他的事务对表A或者表A的任意一行加了锁，
那么对A的每一行都需要检测一次非常耗时，意向锁在原来的x/s锁上引入了ix/is所，ix/is都是表锁，用来表示事务想在表中的
某一个数据行上加x所或者s锁。

    规定：
        一个事务在获得某个数据行对象的读锁之前，必须获得表的is意向读锁或者更强的锁；
        一个事务在获得某个数据行对象的写锁，必须鲜活的所得意向写锁。
        
        
意向锁表示想要对表加锁，而不是真正的加锁；
s锁只与s锁和is锁兼容，也就是说食物相对数据行加s锁，其他事务可以已经获得对表

# 第二章 Java
## Java基础
### 数据类型
基本数据类型：byte/8  char/16 short/16   int/32   float/32 double/64  boolean/-

包装类：基本类型都有对应的包装类型，基本类型与其对应的包装类型，基本类型与其对应的包装类型之间的复制使用自动装箱与拆箱完成
Integer x=2；//装箱
int y=x；//拆箱

缓存池
    new Integer(123) 与Integer，valueOf(123) 的区别在于
    new Integer(123) 每次都会新建一个对象；
    Integer.valueOf(123)会使用缓存池的对象，多次调用会取得同一个对象的引用。

    value.Of()方法实现比较简单，就是判断值是否在缓冲池中，如果在的话就直接返回缓冲池额内容。

    public static Integer valueOf(int i){
        if(i>=IntegerCache.low && i<= IntegerCache.high)
             return IntegerCache.cache[i+(-IntegerCache.low)];
        return new Integer(i);
    }

### String
    String 被声明为final 因此它不可被继承
    在Java8中String内部类使用char 数组存储数据。

    public final class String implements java.io.serializable,Comparable<String>,CharSequence{
        private final char value[];
    }

    在Java9 String实现改用byte数组存储。同时使用coder来标识用了那种编码

    public final class String implements java.io.serializable,Comparable<String>,CharSequence{
        private final byte[] coder;
    }
    value 数组被声明为final 这意味着value数组初始化后就不能引用其他数组。并且String内部没有改变value数组的方法，因此保证String不可变。

  不可变的好处
  1缓存hash值

  2StringPool的需要
  如果String对象已经被建立过了，那么就会从Stringpool 中取得引用。。String不可变才能使用StringPool。

  3安全性
  String经常被作为参数，String不可变性保证参数不可变。

  4线程安全
  String不可变天生具备线程安全，这个可以在多个线程中使用。


  String String Buffer和StringBuilder
       1可变性
       String 不可变
       StringBuffer和StringBuilder 可变
       2线程安全
       String 不可变线程安全
       String Buffer 线程不安全
       StringBuilder 是线程安全的，内部使用Synchronized进行同步。


  StringPool
  字符常量池，保存着所有的字符串字面量，这些字面量在编译器时期就确定，不仅如此，还可以使用String的Intern（）方法在运行
  过程将字符串添加到StringPool中。
  当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法
  进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回
  这个新字符串的引用

  ### 运算
  参数传递：Java的参数是以值传递的形式传入方法中，而不是引用传递。
以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的
地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，
在一方改变其所指向对象的内容时对另一方没有影响。

        public class Dog {
        String name;
        Dog(String name) {
        this.name = name;
         }
         String getName() {
         return this.name;
          }
          void setName(String name) {
          this.name = name;
           }
          String getObjectAddress() {
          return super.toString();
           }
       }
        public class PassByValueExample {
         public static void main(String[] args) {
         Dog dog = new Dog("A");
         System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog);
         System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A
         }
         private static void func(Dog dog) {
          System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog("B");
           System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B }

       }
·   如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。
class PassByValueExample {
public static void main(String[] args) {
 Dog dog = new Dog("A"); func(dog);
 System.out.println(dog.getName()); // B
 }
 private static void func(Dog dog) {

  dog.setName("B");
   }
 }


float 与 double
Java 不能隐式执行向下转型，因为这会使得精度降低。
1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型

隐式类型转换
因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。
但是使用 += 或者 ++ 运算符可以执行隐式类型转换。

























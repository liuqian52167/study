java 多线程编程
#第一章 多线程技能
## 1.1 进程和多线程的概念及优点
进程：
    操作系统结构的基础，是一次程序的执行，是一个程序及其数据在处理机上顺序执行发生的活动，是程序在一个数据集合上的运行的过程，他是系统进行资源的分配和调度的最小单位。
 
 线程：
    线程可以理解为成实在进程中独立运行的子任务。
 Java多线程给的编程方式主要有两种：一种继承Ｔｈｒｅａｄ类，另一种就是实现Runnable接口。
 Thread结构
    public class Thread Implements Runnable
    Thread类实现了Runnable接口，他们之间具有多态关系。其实使用继承Thread类的方式创新线程时，最大的局限是不支持多继承，因为Java语言的特点就是单根继承，所以为了支持多继承，完全可以
    实现runnable接口的方式，一边实现一边继承。但这个类继承Thread，
    并且重写run方法。在run方法中，写线程要执行任务代码如下：
        package com.mythread.www;
        public class MyThread extends Thread{
            @Override
            public void run(){
                super.run();
                System.out.println("MyThread");
                
            }
        }
        
        在使用多线程技术时代码的运行结果与代码执行顺序或调用顺序无关。
   
 异常：1多次调用start() 方法汇报
 Exception in thread main Java.lang.IlleagalThreadStateException
    start()通知线程规划器此线程已就绪，等待调用run方法
    run（）使线程得到运行，启动线程，具有异步执行的效果，如果以调用thread.run
    就不是异步执行，就是同步，那么此线程对象并不交给线程规划器来进行处理，而是youmain方法来调用润方法，也就是必须有run方法执行完成后才可以执行后面的代码。
    start() 方法的顺序并不代表线程启动的顺序。
    
实现Runnable 接口
如果欲创建的线程类已经有一个父类，这时就不能继承Thread类了，因为Java不支持多继承，所以就需要实现Runnable

package myrunnable
public class MyRunnable Implements Runnable{
    @Overrid
    public void run (){
        System.out.prntln("运行中")
    }
}


## 1.2使用多线程
## 1.3 currentThread () 方法
## 1.4 isAlive() 方法
## 1.5 sleep()方法
## 1.6 getId() 方法
getId()的作用失去的线程的唯一标识
public class Test{
    public static void main(String[] args){
        Thread runThread = Thread.currentThread();
        System.out.println(runThread.getName()+" "+ runThread.getId());
    }
}
## 1.7 停止线程
停止线程在多线程开发很重要，需要技巧性处理。

停止线程意味着在线程处理完任务以前停掉正在做的操作，也就是房前当前的操作。停止一个线程
可以使用Thread.stop()方法最好不用他，他不安全，是被废弃的方法。

大多数停止一个线程的的额操作使用Thread.interrupt()方法，这个方法不会终止一个正在运行的程序，需要加入一个判断才能完成线程的
停止。

三种停止现成的方法；1使用推出标志，使线程正常退出，也就是在run方法完成后线程终止。
2使用Stop（）方法强行终止线程，但不推荐使用这个方法，因为它不安全。
3使用interrupt（）方法中断线程

### 1.7.1 停止不了的线程
使用interrupt（） 方法来停止线程，但interrupt（）方法使用效果不想 for+ break 调用interrupt() 方法只是在当前线程中打了个停止的的标记


public class MyThread extends Thread{
    @Override
    public void run(){
      super.run();
        for(int i =0;I<500000;I++){
            System.out.println("i=" (i+1));
        }
    }
}

运行run.java代码
public class  Run{
    public static void main(String [] args){
        try{
            MyThread thread = new MyThread();
            thread.start();
            Thread.sleep(2000);
            thread.interrupt();
        }catch(InterrruptedEcception e){
            System.out.println("main catch");
            e.printStackTraace();
        }
    }
}

### 1.7.2 判断线程是否是停止状态
判断线程是否停止状态，Thread.java提供了两种方法
this.interrupted()测试当前线程是否已经中断
this.isInterrupted()测试线程是否已经中断

interrupted() 声明方法
public static boolean interrupted()

isInterrupted()声明方法
public boolean isInterrupted()

两方法有什么区别

public class MyThread extends Thread{
    @Override
    Public void run(){
        super.run();
        for(int i=0;i<500000;i++){
            System.out.println("i=" + (i+1));
        }
    }
}


类Run.java 
public class Run{
    public static void main(String[] args){
        try{
            MyThread thread = new Mythread();
            thread.start();
            Thread.sleep();
            //Thread.currentThread().interrupt();
            thread.intrrupt();
            System.out.println("是否停止1？" + thread.interrupted());
            System.out.println("是否停止2？" + thread.interrupted());
        }catch(InterruptedException e){
            System.out.println("main catch");
            e.printStackTrace();
        }
        System.out.println("end!");
    }
}


isInterrupted()

## 1.8暂停线程
## 1.9yieId方法
## 1.10线程的优先级
## 1.11 守护线程
#第二章 对象及变量的并发访问
## 2.1 synchronized同步方法
## 2.2 synchronized 同步语法快
## 2.3 volatile 关键字

# 第三章线程间通信
## 3.1 等待/通知机制
## 3.2 方法join的使用
## 类ThreadLocal的使用



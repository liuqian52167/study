# jvm
## 第一章
### Java概述和技术体系
广义上讲，Clojure、Jruby、Groovy等运行在Java虚拟机上的语言及其相关程序都属于Java技术体系的一员。sun官方给的Java技术体系
    定义：
    
    Java程序设计语言
    各种硬件平台上的Java虚拟机
    class文件格式
    来自商业机构和开源社区的第三方Java类库



### 发展史

### 虚拟机发展史
### Java技术的未来
    模块化
    混合语言
    多核并行
    
### 自己编译jdk
## 第二章
第二章Java内存区域与内存溢出异常
第三章垃圾收集器与内存分配策略
第四章虚拟机性能监控与故障处理工具
第五章调优案例分析与实战
### 2.1概述

### 2.2运行时的数据区域
Java虚拟机在执行Java程序的过程中会把它管理的内存划分若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，
有的区域随着虚拟机进程的启动而存在，有些区域则以来用户线程的启动和结束而建立和销毁。
运行时数据区
    方法区 
    虚拟机栈
    堆
    程序计数器
    本地方法栈
   
   执行引擎        本地库接口           本地方法
   
   
   有所有线程共享的数据区
   线程隔离的数据区
   
   #### 程序计数器
    程序计数器是一块较小的内存空间，可以看作是前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字符码解释器的工作时
    通过改变这个计数器的值来选取下一条需要执行字节码指令，分支、循环、跳转、异常处理、县城回复等基础功能都需要以来这个计数器完成。
    
    Java虚拟机的多线程就是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程
    中的指令。因此为了线程切换后恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，个条线程之间计数器互不影响。独立存储
    我们称这类内存区域为线程私有的内存。
    
  #### Java虚拟机栈
  和程序计数器一样，Java虚拟机栈也是线程私有的，他的使命周期与线程相同。虚拟机描述的是Java方法执行的内存模型：每个方法在执行的同时
  都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法调用直至执行完成的过程，就对应着一个栈帧在虚拟
  机中入栈到出栈的过程。
  局部变量存放了编译期可知的各种基本数据类型（8种基本类型）对象引用类型（Reference类型，它不同于对象本身，可能是一个只想对象其实
  地址的引用指针，也可能是指向一个代表对象的句柄或其他与对象相关的位置）和ReturnAddress类型（指向一个字节码指令的地址）
  其中长度为64位的Long和Double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用一个。局部变量表所需要的内存空间在编译期间
  完成分配，但进入一个方法时，这个方法需要在帧中分配多大局部变量空间是完全确定的。在方法运行期间不会干煸局部变量表的大小。
  Java虚拟机规范中对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度就会爆出StackOverFlowError异常。
  动态扩展时，无法申请到足够的内存，就会抛出OutOfMemoryError异常。
 #### 本地方法栈
 本地方法栈与虚拟机所发展的作用相似，它们的区别不过是虚拟机栈为虚拟机执行Java方法（字节码服务）服务，本地方法栈则为虚拟机
 使用的native方法访问。Java虚拟机规范并没有对本地方法栈中的方法使用的语言、使用方式、与数据结构没有强制规定。Java虚拟机
 规范中对这个区域规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的深度就会爆出StackOverFlowError异常。
 #### java堆
 Java堆是Java虚拟机所管理的内存中最大的一块。是所有线程共享的一块内存区域，在虚拟机启动时创建。这个内存区域唯一的目的就是
 存放对象实例，几乎所有的对象实例都是在这里分配内存。
 
 Java堆石垃圾回收器管理的主要区域。因此很多时候被称为GC堆。从内村回收的角度看，现在收集器基本都是采用分代收集算法，所以Java
 堆中可与细分新生代、老年代。更细点Eden空间、FromSurvivor空间、ToSurvivor空间。从内存的分配的角度来看，线程共享的Java堆中可
 能划分了回收内存，或者更快的分配内存
 
 #### 方法区
 方法区和Java堆一样，是各个线程共享内存的区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、及时编译的器编译的后的代码等数据。
 虽然Java虚拟机规范吧方法区描述为堆的一个逻辑部分，他有个名字叫NonHeap 非堆，目的就是与Java堆区分开来。
 
 #### 运行时常量池
 运行时常量池（）是方法区的一部分。这class文件除了有类的版本、字段、方法、接口等描述外，还有一项信息是常量池用于存放编译器生成的
 各种字面变量等信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引号用，这部分内容将类加载后进入方法区的运行常
 量池中存放
 
### 2.3hotSpot虚拟机对象探秘
#### java对象的创建
1创建对象 关键字new 语言层面

虚拟机层面
    
    1当虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载
    解析和初始化过，如果没有，那必须执行相应的类加载过程。
    2类加载检测通过后，接下来秀吉将为新生对象分配内存。随相关所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务相当于把一块确定
    的内存从Java堆中划分出来。Java堆内存绝对规整的分配方式叫指针碰撞。虚拟机维护一个列表记录上哪些是可用的，分配的时候从列表中找到一块足
    够大的空间划分给对象实例。并更新列表上的记录，这种方式成为空闲列表。
    除如何划分可用空间以外，还有个需要考虑的问题是对子昂创建在虚拟机中是否非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发的情况下
    也并不是线程安全的。
    解决方案：对分配内存动作进行同步 
    3内存分配完成后虚拟机需要将分配的分配到的内存都初始化零值（不包括对象头）如果使用本地线程分配缓冲，这个工作过程也可以在本地线程分配缓冲分配时进行
    这一步操作保证了对象的实例字段在Java代码中可以不赋值直接使用，程序能访问到这些字段的数据类型对应的零值。
    
    4虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC的分代年龄等信息
    这些信息存放在对象的对象头之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等对象头会有不同的设置方式。
    
    5虚拟机层面新的对象已经产生了，但节哀吧语言层面对象创建才刚刚开始<init> 方法还没有执行，所有字段都还为0.所以一般来说执行new指令之后接着
    执行<init> 方法吧对象按照程序眼的意愿进行初始化，这样一个真正的可用对象才算完成。
  #### 对象的内存布局
  在hotSpot虚拟机中，对象在内存中存储的布局可以分为三个区域：对象头、示例数据、和对齐填充。
       
    1对象头 分为两部分：一部分用于存储对象自身的运行时数据，如hash吗、GC分代年龄、锁状态标志、偏向线程ID、偏向时间戳。这部分数据
    的长度 markWord是一个非固定的数据结构以便在极小的空间尽可能存储多的数据。
    
    对象在未锁定下的状态下，那么markWord的32位空间里25个bit用于存储对象的哈希码，4bit用于存储对象分代年龄、2bit用于存储锁标志位1bit固定为0.
    
    
    对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
### 2.4OutOfMemoryError 内存溢出

## 第三章
### 3.1概述

## 第四章
## 第五章
## 第六章
## 第七章
## 第八章
## 第九章
## 第十章
## 第十一章
## 第十二章
## 第十三章

# mysql高性能
## 第一章
### mysql的逻辑架构
第一层 最上层的服务，不是MySQL独有，有链接处理、授权认证和安全等
第二层MySQL的狠心服务都在这一层。包括查询解析、分析、优化、缓存以及内置函数（时间、日期数学和加密函数）
第三层包含了存储引擎，存储引擎负责MySQL中数据的存储和提取。存储引擎不会解析sql，不同的存储引擎也不会相互通信，只是简单
的响应上层服务器的请求。

>>第一层客户端

>>第二层
>>>连接线程处理

>>> 查询缓存

>>>解析器

>>> 优化器

>>> 存储引擎

#### 1.1.1链接管理与安全性
客户端连接在服务器进程中拥有一个进程。这个链接的查询只会在独立的线程中执行，该线程只能轮流在某个cpu核心或者cpu中运行
服务器负责存线程，因此不需要为每一个新建的链接创建或者销毁线程。

#### 1.1.2优化与执行

    mysql会解析查询，并创建内部数据结构（解析树），然后对其各种优化，包括重写查询、决定表的读取
    顺序，以及选择适当的索引等。用户可以通过特殊的关键字提示优化器，影响它的决策过程。也可以请求优化器解释优化过程
    的各个因素
    
### 1.2并发控制
mysql 在两个层面的并发：：服务器层和存储引擎层
。本文只关注控制并发读写。

#### 1.2.1读写锁
在处理读或者写的时候可以通过实现一个有两种类型的所组成的所系统来解决问题，共享锁（读锁）、排它锁（写锁）
#### 1.2.2 锁粒度
一种提高共享资源并发的方式就是让锁定对象有更多选择。尽量只锁定只需要修改的部分数据。更理想的方式只会对修改的数据提供
精确的锁定。任何时候在给定的资源上锁定的数据越少，则系统的并发越高.

加锁也需要消耗资源。锁的各种擦做，包括获得锁、检查锁石佛偶已经解除、释放锁都会增加系统开销。
所谓锁策略就是在锁的开销和数据安全这几件寻求平衡。

表锁tablelock

MySQL表锁是基本锁策略，并且是开销最小的策略。表锁他会锁定整张表。一个用户对表进行写操作（插入删除更新）前，需要先获得
写锁，这会阻塞其他用户的对该表的读写操作。读锁之间不不相互堵塞。

行级锁
航机搜索可以最大程度支持并发出路（同时带来最大锁开销）。行级锁旨在存储引擎层实现，在MySQL服务器层没有实现。
### 1.3事务
事务就是一组原子性的sql查询，或者说一个独立的工作单元。

 ``START TRANSACTION;``
 ``SELECT balance FROM checking WHERE custome_id=10233276;``
 ``UPDATE checking SET banlance = banlance -200 WHERE customer_id = 10233276;``
 ``UPDATE saving SET balance = balance +200 WHERE `custom_id=1033276; ``
``COOMMI``
ACID:原子性ctomicity、一致性consistency、隔离性isolation、持久性durablility
 原子性：
 一个事务必须是为一个不可分割的最小工作单元，成功提交，失败回滚。
 
 一致性：
 数据库是藏一个一致性的状态转换到另一个一致性的状态。
 
 隔离性：一般情况下一个事务所做的修改在最终提交以前，对其他事务不可见。重点隔离级别
 
 持久性:事务一旦提交，所做的修改就会永久的 保存在数据库中。此时及时系统崩溃所改数据也不会丢失。持久层也分为狠毒级别。
 
 #### 1.3.1 隔离级别
 隔离性其实比想象的复杂。sql定义了四种隔离级别。
 READ UNCOMMITTED 为提交读
 在这个级别的我 事务中的修改，即使没用提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也称为脏读。这个级别
 会导致很多问题，从性能上来说，READ UNCMMITTED 不会比其他的级别好哦太多，但还是缺乏好处，除非必要不建议使用。
 
 READ COMMITTED 提交读
 
 大多数数据库系统都是这种隔离级别，但MySQL不是。一个事务开始时，只能看见已经提交的事务所作的修改。换句话说，一个事务
 提交以前，所做的任何修改对其他的事务都是不可见的。这个级别也叫不可重复读。
 
 REPEATABLE READ
 （可重复度）它解决了脏读的问题，改级别保证了在一个人事务中多次独缺同样的记录多次读取同样的记录结果是一样的。但是这个
 级别解决不了幻读。幻读就是当某个事务在读取某个范围的记录时，应一个事务又在该范围插入新的记录，当之前的事务再次读取该
 范围的记录是就会产生幻读。
 
 SERIALIZABLE
 可串行化
    
#### 1.3.2死锁
 指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶行循环现象。当多个事务试图以不同的顺序锁
 定资源时，就可能产生死锁。多个事务同事锁定同一个同一个资源是，也会产生死锁。
 
 #### 1.3.3事务日志
 
 #### 1.。3.4 MySQL中的事务
 
 MySQL提供了两种事务型存储引擎InnoDB和NDBCluster。另外还有一些第三方